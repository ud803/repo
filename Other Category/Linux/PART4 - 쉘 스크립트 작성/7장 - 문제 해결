이제는 스크립트들을 더 복잡하게 만들어, 실수를 했을때나 프로그램이 원치않는 동작을 할 때 무슨 일이 벌어지는지 살펴볼 것이다.

1. 구문 오류
일반적인 오류 중 하나는 구문적인 것이다. 구문 오류는 쉘 구문 요소의 잘못된 타이핑을 포함한다. 다음과 같은 스크립트를 작성한다.

  #!/bin/bash
  # trouble : script to demonstrate common erros

  1 number=1
  2 if [ $numbe = 1 ]; then
  3   echo "Number is equal to 1."
  4 else
  5   echo "Number is not equal to 1."
  6 fi

  1) 따옴표 누락
    3번째 줄의 닫음 따옴표를 제거하면, 두 번째 echo이후에서 오류가 나는데, 마침 따옴표 때문이다.
    장문의 편집기에선 이러한 오류를 발견하기가 어렵지만, 문법 하이라이팅 기능을 사용하면 도움이 될 수 있다.
    vim에서 :syntax on

  2) 예상치 못한 토큰이나 토큰 누락
    또 다른 실수는 if나 while 문처럼 합성 명령어를 제대로 완료하지 않는 것이다. if명령어에서 세미콜론을 제거하면 token 에러가 난다.
  3) 예상 외의 확장
    스크립트는 종종 확장의 결과로 인해 제대로 동작하다가도 어느 시점에서 실패한다.
    1번째 줄의 number=를 공백으로 비워두면, 아래 연산에서 [ = 1 ] 이라는 잘못된 연산이 된다.
    이 문제는 test 명령어 첫 번째 인자 주위를 따옴표로 감싸면 해결할 수 있다.
    [ "$number" = 1 ] 그러면 [ "" = 1 ]과 같이 확장된다.


2. 논리 오류
  구문 오류와 달리, 논리 오류는 실행 중에 스크립트를 막지는 않는다. 정상적으로 실행되지만 논리적인 문제 때문에 원하는 결과를 얻을 수 없다.
    -잘못된 조건식
    -Off by one 오류들.
      루프는 1이 아닌 0부터 시작하는 것을 간과할 때. 카운트가 초과해서 "끝을 지나는" 루프가 생기면 나타나는 오류
    -예상치 못한 상황


3. 방어적 프로그래밍
  다음과 같은 코드가 있다고 하자.

    cd $dir_name
    rm *

  만약 dir_name이 실재하는 디렉토리라면 이 두 줄이 잘못된 것은 없다. 하지만 그렇지 않다면? cd 명령은 실패하고 스크립트는 현 디렉토리의 모든 파일을 삭제해 버린다! 좀 더 현명한 프로그래머라면 다음과 같이 코드를 짤 것이다.

  1)  cd $dir_name && rm *

  이 방식에서 앞의 명령이 실패하면 뒤의 명령은 실행되지 않는다. 이는 더 나은 방식이긴 하지만, 여전히 변수가 설정되지 않을 경우 홈 디렉토리의 파일들이 삭제되는 결과를 얻게될 가능성이 존재한다.

  2)  [[ -d $dir_name ]] && cd $dir_name && rm *

  위 코드는 1에 비해 확실히 발전했지만, 오류가 날 경우 그냥 종료되는 것이 최선이다

  3)  if [[ -d $dir_name ]]; then
          if cd $dir_name; then
              rm *
          else
              echo "cannot cd to '$dir_name'" >&2
              exit 1
          fi
      else
          echo "no such directory: '$dir_name'" >&2
          exit 1
      fi

  위 코드는 두 상황 모두를 검사할 수 있다. 실패하더라도 자세한 오류 메시지가 표준 오류로 전해지고, 스크립트는 종료 상태 1로 종료된다.




4. 입력 값 검증
프로그램이 입력 받는 경우 일반적으로 좋은 ㅍ로그래밍 규칙은 어떤 입력을 받더라도 처리 가능한 것이다.
  앞서 작성한

  [[ $REPLY =~ ^[0-3]$ ]]

  이 테스트는 매우 특별하다. 이러한 테스트를 작성하는 것이 힘들 수도 있지만, 고급 스크립트를 위해서는 필수불가결하다.


5. 테스팅
  1) 스텁(Stub)
    이전 논의에서 우리는 스텁이 프로그램을 검증하기 위해 어떻게 사용될 수 있는지 보았다. 이전 파일 삭제 문제를 살펴보고, 쉽게 테스트하기 위해 어떻게 코딩하는지 보자. 원본 코드 조각을 파일들을 삭제하기 때문에 테스트하는 것은 위험할 수도 있다. 따라서 우리는 그 코드를 안전하게 테스트할 수 있게 수정할 것이다.

    if [[ -d $dir_name ]]; then
        if cd $dir_name; then
            echo rm * # TESTING
        else
            echo "cannot cd to '$dir_name'" >&2
            exit 1
        fi
    else
        echo "no such directory: '$dir_name'" >&2
        exit 1
    fi
    exit # TESTING

    여기서는 rm을 직접 실행하는 대신 echo가 그 자리를 대신한다.
    나중에 찾기 쉽기 위해 TESTING이라는 마킹을 해준다.

  2) 테스트 케이스
    효과적인 테스트를 위해 좋은 테스트 케이스를 개발하고 적용하는 것 또한 중요하다. 테스트 케이스는 엣지 케이스(edge case)와 코너 케이스(corner case)를 반영하여 입력 데이터와 작동 상태를 주의깊게 선택하는 것으로 이뤄진다. 앞서 사용한 코드에서 다음 세 가지 조건하에서 코드가 어떻게 수행되는지 보자
      - dir_name이 존재하는 디렉토리를 포함한 경우
      - dir_name이 존재하지 않는 디렉토리를 포함한 경우
      - dir_name이 비어있는 경우
    이들 조건을 각각 테스트하여 좋은 테스트 커버리지를 만들 수 있다.

  3) 디버깅
    테스팅에서 스크립트의 문제가 드러나면, 그 다음은 디버깅이다. 어떤 면에서 "문제"란 프로그래머의 예상대로 수행되지 않은 스크립트를 의미한다. 이러한 경우에 스크립트가 어떻게 동작하고 왜 그렇게 동작하는지 주의 깊게 확인할 필요가 있다.
      a. 문제 발생 지역 발견
      긴 스크립트에서는 문제가 되는 스크립트 영역을 격리하는 게 유용하다. 코드 격리의 한 방법은 스크립트 일부를 주석화시키는 것이다.

      b. 트레이싱
      프로그램의 실제 흐름을 보기 위해 우리는 트레이싱이라는 기법을 사용한다. 트레이싱의 한 가지 방법은 스크립트 내에 실행위치를 표시하는 정보 메시지를 포함시키는 것이다.
        echo "preparing to delete files" >&2
        echo "deleting files" >&2
      일반적인 출력과 그 메시지들을 구분하기 위해 표준 오류로 전달한다.

      또한 bash는 #!/bin/bash -x 옵션으로 트레이싱을 제공한다!!!
      더하기 기호는 일반적인 출력과 구별하여 트레이스 출력을 가리킨다. 더하기 기호는 트레이스 출력의 기본 문자인데, 이것은 PS4(프롬프트 문자열 4) 쉘 변수에 포함된다. 행 번호를 포함하기 위해 다음과 같이 수정할 수 있다.

        export PS4='$LINENO + '

      스크립트 전체가 아닌 선택 영역에 트레이스를 수행하기 위해서는 set 명령어와 x 옵션을 사용할 수 있다.

      set -x # Turn on tracing
      .
      .
      .
      set +x # Turn off tracing

      c. 실행 중에 값 확인
      이는 트레이싱과 마찬가지로 때때로 실행 중에 스크립트의 내부 동작을 확인할 변수의 내용을 표시하는 경우 유용하다.
