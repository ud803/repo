0. 정규 표현식이란 텍스트에서 패턴을 인식하는 심볼 표기법이다. 어떤 면에서는 파일과 경로명 매칭에 사용하는 쉘의 와일드카드 방식과 닮았지만 보다 웅장한 규모다. 정규 표현식은 대부분의 프로그램에 제공되지만, 약간씩 상이하다. 여기서는 POSIX 표준 정규 표현식으로 이야기할 것이다.

1. grep - 텍스트를 통한 검색
grep이란 global regular expression print에서 유래된 이름이다. 기본적으로 grep은 지정된 정규 표현식과 일치하는 표준 출력을 가진 행을 출력한다.

  grep [options] regex [file...]
  -i  : 대소문자 무시. 대문자와 소문자를 구분하지 않는다. --ignore-case
  -v  : 반전 매치. 일반적으로 grep은 일치하는 행을 출력한다. 이 옵션은 이리하지 않는 모든 행을 출력한다. --invert-match
  -c  : 일치한 행 자체가 아닌 행의 수를 출력한다. --count
  -l  : 일치한 행 자체가 아닌 이를 포함한 각각의 파일 이름을 출력한다. --files-with-matches
  -L  : 위와 유사하지만, 일치하는 행이 없는 파일의 이름만을 출력한다. --files-without-match
  -n  : 일치하는 행 앞에 파일의 행 번호를 붙인다. --lines-number
  -h  : 복수 파일 검색에서, 파일명의 출력을 숨긴다. --no-filename

ls /usr/bin | grep zip
이는 /usr/bin 디렉토리에 있는 zip이라는 문자열을 파일명에 포함한 모든 파일을 나열한다.


2. 메타문자와 리터럴
정규표현식 bzip은 문자 그 자체로 일치되는 상수 문자(literal characters)다. 정규 표현식은 리터럴 외에도 메타문자를 포함할 수 있는데, 그것은 더 복잡한 매치 식을 지정하는 데 사용된다. 다음으로 구성되어있다.

  ^ $ . [ ] { } - ? * + ( ) | \

백슬래시 문자는 메타시퀀스를 생성하는 경우에 사용되긴 하지만 나머지 모든 문자들은 리터럴로 간주된다. 메타문자들도 메타문자로 인터프리트되는 대신에 확장되거나 리터럴로 처리될 수 있다.

  . 도트 문자
    어떤 문자든지 일치하게 하는 도트 문자이다.
    grep -h '.zip' pathname 을 실행하면, zip자체를 찾을 수 없는데, 도트 문자까지 포함하여 4글자가 되어야 하기 때문이다.

  ^ (캐럿) $(달러) 문자
    이 문자들은 앵커(anchors)로 처리된다. 이는 해당 정규 표현식이 행의 시작(^)이나 행의 끝($)에서 발견되는 경우에만 일치하게 된다는 것을 의미한다.
    ^zip  zip$  ^zip$
    ^$는 공백을 의미
    십자말 풀이 - /usr/share/dict/words
    grep -i '^..j.r$' /usr/share/dict/words

  [] (괄호) 문자
    비교할 문자 집합을 지정할 수 있다
    grep -h '[bg]zip' dirlist*.txt
    메타문자는 괄호 표현식에서 다른 의미로 사용되는데, ^(캐럿)은 부정, -(대시)는 범위를 나타낸다.
    복수 표현도 가능하다 grep -h '^[A-Za-z0-0]' dirlist*.txt
    메타문자를 포함하고 싶으면, 맨 앞으로 보내준다 grep -h '[-AZ]' dirlist*.txt

3. POSIX 문자 클래스
  전통적인 문자 범위는 쉽게 이해되고 문자 집합을 빠르게 지정하기에 효율적인 방식이지만, 항상 동작하지는 않는다. 지금까지 grep을 사용하면서 어떤 문제와도 맞닥뜨리지 않았다면 다른 프로그램들을 사용하여 문제를 일으켜 볼 것이다.

  [[:alnum:]] ASCII 알파벳과 숫자; [A-Za-z0-9]와 동일
  [[:word:]]  위와 동일, 밑줄(_)문자 추가됨
  [[:alpha:]] ASCII 알파벳; [A-Za-z]와 동일
  [[:blank:]] 스페이스와 탭 문자
  [[:cntrl:]] ASCII 제어코드; ASCII 문자 0부터 31번, 127번
  [[:digit:]] 숫자 0부터 9
  [[:graph:]] 출력 가능한 그래픽 문자; ASCII 33번부터 126까지
  [[:lower:]] 소문자
  [[:punct:]] ASCII 구두점 기호
  [[:print:]] 출력 가능 문자; graph에 스페이스 문자 추가
  [[:space:]] 공백 문자. ASCII의 스페이스, 탭, 캐리지, 리턴, 개행, 수직 탭, 폼 피드 포함
  [[:upper:]] 대문자
  [[:xdigit:]]16진수를 표현하는 ASCII 문자; [0-9A-Fa-f]와 동일


4. POSIX 기본 vs. 확장 정규 표현식
POSIX를 구현하는 방법은 기본 정규 표현식(BRE)과 확장 정규 표현식(ERE) 이다. 지금까지 다룬 내용은 POSIX 방식의 BRE를 구현하는 응용들이다. 둘의 차이점은 메타문자와 관계가 있다.
  BRE는 다음과 같은 메타문자들을 구분한다. ^ $ . [] * 그 외 다른 문자들은 리터럴 문자로 인식된다.
  ERE에는 다음의 메타문자들이 추가된다. () {} ? + |
  하지만 () {} 기호는 BRE에서는 백슬래시가 항상 함께 쓰여야만 메타문자로 인식되지만, ERE에서는 메타 문자 앞에 백슬래시 기호를 사용하게 되면 리터럴 문자임을 의미한다.
  여기서 다룰 부분은 ERE에 관한 것이며, 다른 버전의 grep을 사용하게 될 것이다. 일반적으로, egrep이라는 프로그램이 수행될 수 있다. 또한 GNU 버전의 grep도 -E 옵션을 사용되면 확장 정규 표현식을 지원한다.

  1) 얼터네이션(Alternation)
  이것은 표현식 집합 가운데에서 일치하는 것을 찾아주는 기능이다.
  echo "CCC" | grep -E 'AAA|BBB'   혹은 echo "CCC" | egrep 'AAA|BBB'
  둘 중 일치하는 것을 찾는 명령어이고, 확장 기능이기 때문에 -E 옵션을 사용하거나 egrep 명령을 사용한다.
  정규 표현식을 따옴표로 감싸는 것은 수직 파이프 메타문자를 파이프 연산자와 헷갈리는 것을 방지하기 위해서다.

  얼터네이션과 다른 정규 표현식을 결합하여 사용하려면 () 기호로 구분해준다.
  grep -Eh '^(bz|gz|zip)' dirlist*.txt  : bz, gz, zip으로 시작하는 행을 갖는 파일 검색

  2) 수량 한정자
  확장 정규 표현식은 하나의 요소를 찾는 횟수를 지정하는 여러 방법을 지원한다.
    ? - 항목이 없거나 한 번만 나타나는 경우 (그 앞이 선택적인 요소임)
    '^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$'

    * - 항목이 없거나 여러 번 나타나는 경우
    대문자로 시작하고, 여러 대소문자와 공백을 포함하고 있으며 마침표로 끝나는 문장
    [[:upper:]][[:upper:][:lower:] ]*\.
    echo "This works." | grep -E '[[:upper:]][[:upper:][:lower:] ]*\.'

    + - 항목이 한 번 이상 나타나는 경우
    * 메타문자는 *와 거의 비슷하다. 단, 찾으려는 요소와 일치하는 개체가 하나 이상 있어야 한다는 것을 제외하곤 말이다.
    단일 스페이스로 구분된 하나 이상의 알파벳으로 구성된 그룹을 찾는 정규식
    ^([[:alpha:]]+ ?)+$
    echo "This that" | grep -E '^([[:alpha:]]+ ?)+$'      This that
    echo "a b c" | grep -E '^([[:alpha:]]+ ?)+$'          a b c
    echo "a b 9" | grep -E '^([[:alpha:]]+ ?)+$'          출력 없음, 숫자 존재
    echo "abc  d" | grep -E '^([[:alpha:]]+ ?)+$'         출력 없음, 스페이스가 둘

    {} - 항목이 지정된 횟수만큼 나타나는 경우
    {, } 메타 문자는 검색 횟수의 최소와 최대값을 지정할 때 사용된다.
      {n}   정확히 n번만 일치하는 선행 요소 검색
      {n,m} 최소 n번, 하지만 m번 미만으로 일치하는 선행 요소 검색
      {n,}  n번 이상 일치하는 선행 요소 검색
      {, m} m번 미만 일치하는 선행 요소 검색

    전화번호 예 )
      '^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$'
      '^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$' 로 표현 가능


4. 정규 표현식 활용

    1) grep 명령어로 유효한 전화번호 찾기
    for i in {1..10}; do echo "(${RANDOM:0:3}) ${RANDOM:0:3}-${RANDOM:0:4}" >> phonelist.txt; done
    임의의 10개 전화번호 생성

    grep -Ev '^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$' phonelist.txt 를 통해 검색


    2) find로 잘못된 파일명 찾기
    grep은 표현식과 일치하는 문자열이 포함된 결과를 출력하지만, find는 정규 표현식과 정확히 일치하는 경로명이 필요하다.

    find . -regex '.*[^-_.\0-9a-zA-Z].*'


    3) locate로 파일 검색하기
    locate 프로그램은 기본 정규 표현식(--regexp) 및 확장 정규 표현식(--regex) 모두를 지원한다.


    4) less와 vim으로 텍스트 검색하기
    less와 vim 모두 /키를 입력하고 정규 표현식을 입력하면 검색이 실행된다
    less에서,
    /^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$

    vim 프로그램은 기본 정규 표현식을 지원하기 때문에 위의 표현은 다음과 같이 변경된다.
    /([0-9]\{3\}) [0-9]\{3\}-[0-9]\{4\}

    확장 표현식에서 메타문자로 여겨지는 문자들이 기본 표현식에서는 리터럴로 인식되기 때문에 백슬래시로 확장해준다.
    :hlsearch : 검색 결과 하이라이트
