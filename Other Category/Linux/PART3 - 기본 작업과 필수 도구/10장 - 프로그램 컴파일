0. 리눅스의 기본적인 자유로움은 소스 코드의 사용에서 비롯된다. 리눅스 생태계 전체는 개발자들의 자유로운 교류에 의지한다. 대다수의 데스크톱 사용자들에게 컴파일은 잊혀진 기수리다. 예전에는 꽤 흔히 사용되었지만, 현재는 배포판 공급업체에서 이미 컴파일된 바이너리들을 저장소에 관리하기 때문에 다운로드해서 바로 사용할 수 있다. 왜 소프트웨어를 컴파일해야 할까?
  - 가용성 : 저장소에 있는 다양한 프로그램에도 불구하고, 어떤 배포판은 사용자가 원하는 모든 프로그램을 가지고 있지 않을 수도 있다. 이런 경우, 필요한 프로그램을 얻는 방법은 소스로부터 그 프로그램을 컴파일하여 만드는 것뿐이다.
  - 적시성 : 어떤 배포판은 최신의 프로그램들을 가지고 있는 반면, 그렇지 않은 경우도 많다. 가장 최신 버전을 갖기 위해서는 컴파일이 필수적이다.


  make : 프로그램 관리 유틸리티

1. 컴파일링이란?
컴파일링이란 소스 코드를 컴퓨터 프로세서의 언어로 번역하는 절차다.
컴퓨터 프로세스(또는 CPU)는 매우 기본적인 단계에서 동작한다. 그것은 기계어로 프로그램들을 실행한다. 기계어는 "바이트 더하기", "메모리 위치 가리키기", "바이트 복사하기" 등과 같이 간단한 명령들을 설명하는 숫자 코드다. 각각의 명령어들은 이진법으로 표현된다. 최초의 컴퓨터 프로그램들은 이 숫자 코드로 쓰여졌다.

이 문제는 어셈블리어의 출현으로 극복됐다. 숫자 코드를 대신하기 위해 CPY(copy), MOV(move)와 같은 더 쉽게 사용할 수 있는 연상기호(니모닉)을 사용하였다. 어셈블리어로 짜인 프로그램들은 어셈블러라는 프로그램에 의해 기계어로 처리되었다. 어셈블리어는 디바이스 드라이버와 임베디드 시스템 등과 같은 특정 작업에서 오늘날까지 사용되고 있다.

2. 모든 파일이 컴파일되는가?
이미 본 것처럼, 쉘 스크립트와 같은 일부 프로그램들은 컴파일은 필요 없고 직접 실행된다. 이들은 스크립트 또는 인터프리트 언어로 알려진 프로그래밍 언어로 작성되었다. 최근 몇 년 새에 인기가 상승하였으며, 펄(Perl), 파이썬(Python), PHP, 루비(Ruby) 등과 같은 언어가 이에 해당한다.

스크립트 언어는 인터프리터라고 불리는 특수한 프로그램에 의해 실행된다. 인터프리터는 프로그램 파일을 입력 받아 읽고 파일 내부의 각 명령어들을 실행한다. 일반적으로 인터프리트된 프로그램들은 컴파일된 프로그램보다 아주 느리게 실행된다. 이것은 인터프리트된 프로그램 내의 소스 코드 명령이 매번 번역되고 실행되기 때문이다. 반면 컴파일된 프로그램의 소스 코드는 한 번만 해석되고 이 내용은 최종 실행 파일에 영구적으로 기록된다.

그럼 왜 인터프리트 언어가 인기가 많을까? 실제적인 장점은 일반적으로 컴파일된 프로그램보다 더 빠르고 쉽게 프로그램을 개발할 수 있다는 것이다. 프로그램의 크기가 커짐에 따라 컴파일 단계는 꽤 오랜 시간이 걸릴 수 있지만, 인터프리터는 그 단계가 없기 때문에 프로그램 개발에 속도를 낼 수 있다.


2. C 프로그램 컴파일하기
헤더 파일로 알려진 .h 파일들은 평범한 텍스트 파일이다. 헤더 파일은 소스 코드나 라이브러리에 포함된 루틴에 대한 설명을 가지고 있다. 컴파일러는 프로그램을 완성하기 위해 필요한 모든 모듈의 정보를 받아야 하고 이로 모듈을 연결한다.

  1) 프로그램 빌드하기
  대부분의 프로그램은 다음 두 명령어로 간단히 빌드된다
    ./configure
    make
  configure 프로그램은 소스 트리와 함께 제공된 쉘 스크립트이며 빌드 환경을 분석하는 역할을 한다. 대부분의 소스 코드는 이식 가능하게 설계된다. 즉 유닉스형 시스템 중 하나 이상의 시스템에서 빌드할 수 있도록 설계된다는 것이다.

  configure는 쉘이 일반적으로 예상하는 프로그램들의 위치에 있지 않기 때문에 반드시 ./와 함께 사용해야 한다.

  Makefile은 make 프로그램이 정확히 어떻게 프로그램을 빌드하는지를 알려주는 설정 파일이다. 그 파일이 없다면 make는 실행되지 않는다. Makefile은 일반 텍스트 파일이다.

  make프로그램은 최종 프로그램으로 구성되는 요소들 간의 관계와 의존성을 기술한 makefile을 입력 받는다.
  makefile의 첫 부분은 makefile의 뒷부분의 섹션에서 치환될 변수를 정의한다.

  makefile의 대부분은 타겟(target)과 타겟 생성에 의존적인 파일들의 정의로 라인을 구성한다. 이 예제에서는 diction 실행파일이 타겟이 된다.

  make로 빌드하게 되면 프로그램이 나타나게 된다. 다시 한 번 make를 실행하면, 아무 일도 일어나지 않는데, 이는 make는 모든 것을 간단히 다시 빌드하기보다 필요한 것만 빌드하기 때문이다. 타겟 중 하나를 삭제하고 다시 실행할 경우 make가 동작한다.
  또한 make는 타겟이 의존 파일보다 최신이 되도록 한다. 만약 touch 프로그램으로 소스 파일 중 하나를 갱신하면 make는 다시 타겟을 더 새롭게 만들게 된다.


3. 프로그램 설치하기
잘 패키징된 소스 코드는 종종 install이라 부르는 특별한 make타겟을 가지고 있다. 이 타겟은 시스템 디렉토리에 최종 사용 제품을 설치할 것이다. 주로 이 디렉토리는 /usr/local/bin이다.

  sudo make install
  which diction
  man diction

이제 새로운 프로그램이 생겼다!
