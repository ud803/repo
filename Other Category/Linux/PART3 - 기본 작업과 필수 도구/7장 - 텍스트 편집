0.
  cat   : 파일과 표준 출력을 연결
    cat프로그램은 흥미로운 옵션이 많은데, 그 중 다수는 텍스트 내용을 좀 더 시각적으로 보이게한다.
      -A 텍스트 내의 비출력 문자를 표시한다. 탭은 ^I, $는 스페이스가 뒤따라옴을 의미
      -n 줄 번호를 매긴다
      -s 여러 공백 줄을 제거한다. 한 줄일 경우 한 줄만 남겨둠.

  sort  : 텍스트 파일의 행 정렬
    sort프로그램은 표준 입력이나 커맨드라인에 명시된 하나 이상의 파일의 내용물들을 정렬하고 표준 출력으로 결과를 전달한다. cat과 동일한 방식으로 직접 키보드로부터 표준 입력을 처리할 수 있다.

    sort file1 file2 file3 > total_file  하나의 정렬된 파일로 합치기
      -b  각 줄의 첫 공백을 무시하고 첫 문자를 기준으로 정렬
      -f  정렬 시에 대소문자 구분 않음
      -n  문자열의 숫자 값을 기준으로 정렬. 알파벳 대신 수치를 기준으로 정렬함
      -r  역순으로 정렬
      -k  필드 전체가 아닌 키 필드로 지정된 field1부터 field2까지를 기준으로 정렬 --key= field1[,field2]
      1)
          field는 왼쪽부터 적용됨
          rwxr-xr-x 1 root root    15396752  4월 29 17:39 snap
          여기서 다섯 번째 키는 용량이 된다!

          sort --key=1,1 --key=2n distros.txt
          key에서 범위의 의미는, 연속된 필드일 경우 1,2같이 쓸 수 있지만 1,3필드를 쓰고 싶을 때 복수의 키를 사용한다고 한다.

          2) 필드 내의 특정 영역을 지정할 때
          Fedora  10  11/25/2008
          sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt
          3번 칼럼의 7번째 문자열, 3번 칼럼의 4번째 문자열..
      -m  이미 정렬된 파일명을 각각 인자로 처리. 복수의 파일을 추가적인 정렬 없이 하나의 정렬된 결과로 합침
      -o  정렬된 결과를 표준 출력이 아닌 file로 보냄 --output= file
      -t  필드 구분 문자를 정의. 기본적으로 스페이스나 탭으로 필드를 구분
          공백으로 구분하지 않는 파일의 경우,
          sort -t ':' -k 7 /etc/passwd | head 처럼 특정 문자를 구분자로 삼는다.
      -u  중복 제거


  uniq  : 중복된 행을 생략하거나 보고, 반드시 sort 되어있어야 한다.
          GNU버전의 sort는 정렬된 결과로부터 중복을 제거하는 -u 옵션을 제공한다!

      -c    중복 발생 횟수와 함께 중복 행의 목록을 출력한다
      -d    유일한 행이 아닌 중복된 행들만을 출력
      -f n  각 행에서 n필드까지는 무시, sort에서 공백으로 구분한 것과 달리 uniq는 다른 필드 구분자를 설정하는 옵션이 없다!
      -i    대소문자 구별을 하지 않는다
      -s n  각 행의 n개 문자까지 무시
      -u    유일한 행들만 출력






1. 텍스트 자르고 붙이기

  cut   : 파일의 행에서 일부 영역 제거, 기존 파일에 변화는 없다.
          cut프로그램은 행에서 텍스트 일부를 추출하고 그 부분을 표준 출력을 보놴다. 복수의 파일 인자나 표준 입력으로부터 입력을 허용한다. 행의 추출할 영역을 지정하는 것이 약간 어색하긴 하다.

          cut은 융통성이 없는데, 사용자가 직업 입력한 텍스트보다 다른 프로그램이 생성한 파일의 텍스트를 추출하는 데 적합하다.

      -c char_list    char_list에 정의된 영역을 추출한다. 이 목록은 하나 이상의 콤마로 구분된 숫자 범위
      -f filed_list   filed_list에 정의된 하나 이상의 필드를 추출한다. 이 목록은 하나 이상의 필드거나 콤마로 구분된 필드 범위
      -d delim_char   -f를 지정했을 때, delim_char를 필드 구분자로 사용한다. 기본적으로 필드들은 하나의 탭문자로 구분되어야 한다
      --complement    -c와 -f로 명시된 영역을 제외한 모든 부분을 추출한다

      SUSE    1.10    12/07/2005 예시에서
      cut -f 3 distros.txt를 통해 3번째 칼럼인 12/07/2005를 분리 가능
      이어서 | cut -c 7-10을 통해 7번째~10번째 문자인 2005를 분리 가능!

      cut -d ':' -f 1 /etc/passwd | head
      콜론 문자를 구분자로 지정!


  paste : 파일들의 행들을 합침
          cut의 반대 명령어이다. 파일에서 텍스트 열을 추출하는 대신에, 파일에 하나 이상의 텍스트 열을 추가한다. 복수의 파일을 읽어 들이고, 각 파일에서 찾은 필드를 표준 출력의 단일 스트림으로 결합한다.

          paste fileA fileB  fileA 내용을 fileB에 그대로 붙임 (앞에다가)


  join  : 공통 필드로 두 파일의 행을 합침
          paste와 비슷해 보이지만, join은 항상 공유키 필드로 복수의 테이블에서 자료를 가져와 원하는 결과의 형태로 합치는 관계형 데이터베이스와 관련된 작업이다.
          join이 제대로 작동하려면 파일들이 키 필드를 기준으로 정렬되어 있어야 한다.

          join distros-key-names.txt distros-keyvernums.txt

          기본적으로 join은 입력 필드 구분자로 공백 문자를 사용하고 출력 필드 구분자로 하나의 스페이스를 이용한다. 이러한 방식은 옵션을 지정하여 변경할 수 있다.




2. 텍스트 비교
텍스트 비교는 텍스트 파일들의 버전을 비교하는 데 종종 유용하다. 이는 시스템 관리자들과 소프트웨어 개발자들에게 중요한 부분이다. 프로그래머도 유사하게 프로그램을 만드는 동안 변경내역을 자주 확인할 필요가 있다.

  comm  : 행 단위로 정렬된 두 파일을 비교
          comm프로그램은 두 텍스트 파일을 비교하고 각각 유일한 행과 공통된 행들을 표시한다.

          comm -options file1 file2

          첫째 열은, 첫 번째 파일 인자의 유일한 행
          둘째 열은, 두 번째 파일 인자의 유일한 행
          셋째 열은, 두 파일의 공통 행

          -n : 제거할 열을 설정한다. 3열(공통된 열)만 출력하고 싶으면 -12 옵션을 설정


  diff  : 행 단위로 파일 비교
          diff는 comm에 비해 더 복잡한 툴이며, 많은 출력 포맷을 지원하고 한꺼번에 많은 텍스트 파일들을 처리할 수 있다. diff는 소스 트리라 불리는 소스 코드의 디렉토리르 재귀적으로 확인할 수 있는 능력을 가지고 있다. diff의 일반적인 사용 중 하나는 diff파일을 만들거나 패치를 생성한다. 패치는 파일(파일들)의 한 버전에서 다른 버전으로 변환하기 위해 patch와 같은 프로그램에서 사용된다.

          diff -options file1 file2
            1) 포맷 1 -diff 변경 명령
            r1ar2 두 번째 파일의 r2 위치에 있는 행을 첫 번째 파일의 r1 위치에 추가
            r1cr2 r1위치에 있는 행을 두 번째 파일의 r2 위치의 행으로 변경
            r1dr2 두 번째 파일의 r2 범위에 있어야 할 행을 첫 번째 파일의 r1 위치에서 삭제

            2) 포맷 2 - 문맥 방식   -c
            *** 1,4 ***는 범위 표현
            (없음)  문맥 표시 행. 두 파일 간의 차이점이 없다
            -      삭제된 행. 이 행은 첫 번째 파일에는 나타나지만 두 번째 파일에는 나타나지 않는다
            +      추가된 행. 이 행은 두 번째 파일에는 나타나지만 첫 번째 파일에는 나타나지 않는다
            !      변경된 행. 이 행은 두 가지 버전이 표시될 것이다. 변경 내역의 각자 영역에 각각 표시

            3) 포맷 3 - 통합 방식   -u
            (없음)  이 행은 두 파일 모두 공유한다
            -      이 행은 첫 파일에서 삭제되었다
            +      이 행은 첫 파일에 추가되었다


  patch : diff 파일을 원본 파일에 적용
          patch 프로그램은 텍스트 파일에 수정 내용을 적용하기 위해 사용된다. diff의 출력 결과를 받아서 이전 버전의 파일을 새 버전으로 변환시키는 데 일반적으로 사용된다.
          diff 파일은 커널의 예전 버전과 기여자가 변경한 새 버전 간의 변경 내역을 포함하고 있다. diff의 수신자는 patch 프로그램을 사용하여 자신의 소스 트리에 변경 내역을 적용한다. diff/patch의 사용은 두 가지의 이점이 있다.
            - diff 파일은 전체 소스 트리의 크기에 비해 매우 작다
            - diff 파일은 변경 내역을 간결하게 보여 준다. 패치 검토자가 빠르게 평가할 수 있다

          diff -Naur file1.txt file2.txt > patchfile.txt
          patch < patchfile.txt
          를 하면 file1이 자동으로 패치된다. 패치를 위해 대상 파일(file1)을 지정해주지 않았지만, diff 파일(통합 방식)은 이미 헤더에 그 파일명을 포함하고 있다.




3. 신속한 편집
  지금까지 경험한 텍스트 편집기는 대체로 대화형이었다. 즉 수동으로 커서를 여기저기 이동하고 변경 내용을 타이핑하였다. 하지만 텍스트 편집을 위한 비대화형 방시고 존재한다. 에를 들면, 하나의 명령어로 복수의 파일에 수정할 수 있다.

  tr    : 문자를 변환하거나 삭제
          tr프로그램은 문자들을 변환(transliterate)하는 데 사용된다. 문자 기반 검색 및 치환 작업의 일종으로 생각될 수 있다. 문자 변환은 하나의 알파벳에서 다른 것으로 문자들을 변경하는 작업이다. 예를 들면, 소문자에서 대문자로 문자들을 변환하는 것이다.

          echo "lowercase letters" | tr a-z A-Z

          tr은 표준 입력을 받아 표준 출력으로 결과를 전달한다. tr은 변환할 문자열 집합과 이에 상응하는 변환될 문자열 집합의 두 인자를 받는다. 문자 집합은 다음 세 가지 방식 중 하나로 표현된다.
            -열거 목록 : 예를 들면, ABCDEFGHIJKLMOPQRSTUVWXYZ
            -문자 범위 : 예를 들면, A-Z (로케일 조합 순서 때문에 주의해서 사용)
            -POSIX 문자 클래스 : 예를 들면, [:upper:]

          대부분의 경우에, 문자 집합은 동일한 길이여야 하지만 특별히 여러 문자들을 하나의 문자로 변환하기를 원한다면 첫 번째 집합을 두 번째보다 더 크게 만들 수 있다.

          tr은 문자열을 단순히 입력 스트림에서 삭제할 수 있다.
          tr -d '\r' < dos_file > unix_file

          dos_file에는 변환할 파일을, unix_file에는 결과 파일을 지정한다. 이스케이프 문자열 \r을 사용하여 캐리지 리턴 문자를 표현한다.


          1)
          ROT13 암호화(인코딩) : 이는 단순 치환 암호에 기반을 둔 기초적인 암호화 형태이다
          각 문자를 알파벳 13글자만큼 이동시키 것이다.
          echo "secret text" | tr a-zA-Z n-za-mN-ZA-M

          2)
          -s 옵션은 반복 개체롤 축소한다.
          echo "aaabbbccc" | tr -s ab
          abccc




  sed   : 텍스트의 필터링과 변환을 위한 스트림 편집기
          sed란 이름은 stream editor의 약자다. 텍스트 스트림과 명시된 파일 집합과 표준 입력에서도 텍스트 편집을 수행한다. sed는 강력하고 다소 복잡한 프로그램이다. 일반적으로 sed가 동작하는 방식은 단일 편집 명령어나 복수의 명령어를 포함한 스크립트 파일이 주어진다. 그러고 나서 이 명령어들은 텍스트 스트림의 각 행 위에서 수행된다.

          Option
          -n  수동 출력 옵션. sed는 기본적으로 모든 행을 출력하기 때문에 이를 사용한다
          -f  스크립트 파일을 통해 좀 더 복잡한 명령 가능
          -i  제자리 편집, 편집 결과가 표준 출려이 아닌 그 파일 자신에 쓰인다. 또한 세미콜론으로 구분된 행에서 여러 명령을 수행 가능함.
          sed -f distros.sed distros.txt



1	# sed script to produce Linux distributions report
2
3	1 i\
4	\
5	Linux Distributions Report\
6
7	s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/
8	y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/

3~6행은 입력의 첫 행인 주소 1에 삽입될 텍스트를 포함하고 있다. i 명령어 뒤에는 확장 캐리지 리턴을 생성하기 위해 백슬래시-캐리지 리턴 문자열이 붙는다. 이 문자열은 행 끝에 도달한 인터프리터가 표식 없이 텍스트 스트림에 캐리지 리턴의 내장을 허용하는 쉘 스크립트를 포함한 많은 상황하에서 사용될 수 있다. i 명령어와 명렁어 a(텍스트 추가)와 c(텍스트 교체)는 다수의 행을 허용한다. 마지막 행을 제외하고 행 지속 문자로 끝나는 각 행을 공급한다. 스크립트의 6번째 행은 실제로 삽입된 텍스트의 마지막이고, 행 지속 문자가 아닌 i 명령어의 끝 표시인 일반 캐리지 리턴으로 끝난다.



          기본 편집 명령어)
          = 현재 행 번호를 출력
          a 현재 행 뒤에 텍스트를 추가
          d 현재 행 삭제
          i 현재 행 앞에 텍스트를 삽입
          p 현재 행을 출력. -n 옵션을 명시하여 무시
          q sed는 더 이상 처리할 행이 없으면 종료한다. -n 옵션이 없으면 현재 행 출력
          Q sed는 더 이상 처리할 행이 없으면 종료한다
          s/regexp/replacement/ regexp를 replacement로 치환 , 한 번만 바뀐다!! 뒤에 /g를 붙여야 반복 적용!
          y/set1/set2/  set1 문자들을 set2에 상응하는 문자들로 변경. sed는 tr과 달리 동일한 길이의 집합이 필요하다


          1)
          sed의 명령은 한 글자로 시작한다. 이어서 슬래시 문자로 구분된 검색할 문자열과 대체할 문자열이 따라온다. 구분 문자의 선택은 임의로 정할 수 있다. s뒤에 바로 따라오는 문자를 변경해주면 구분자도 바뀐다.
          echo "front" | sed 's/front/back/'   혹은 echo "front" | sed 's_front_back_'
          back

          2)
          sed의 다수 명령어들은 편집될 입력 스트림의 행 번호를 지정한 주소를 앞세운다. 만약 그 주소를 생략하면, 편집 명령은 입력 스트림의 모든 행에 실행된다. 주소의 가장 간단한 형태는 행 번호다.
          echo "front" | sed '1s/front/back/'
          back
          echo "front" | sed '2s/front/back/'
          front

            주소 표현 방식
            n           n은 양수인 행 번호
            $           마지막 행
            /regexp/    POSIX 기본 정규 표현식과 일치하는 행들
            addr1,addr2 addr1부터 addr2까지의 범위의 행들, 어떤 주소가 와도 상관 없음
            first~ step first 번호의 행과 그 다음 간격마다 모든 행
            addr1,+n    addr1 번호의 행과 다음 n개의 행들
            addr!       addr을 제외한 모든 행


          3) 예제
          sed -n '1,5p' distros.txt     1~5행 출력
          sed -n '/SUSE/p' distros.txt  정규표현식(SUSE)가 들어간 행 출력
          sed -n '/SUSE/!p' distros.txt 정규표현식에 일치하지 않는 행 출력

          4) 심화 예제
          sed 's/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/' distros.txt

          sed 's/regexp/replacement/' distros.txt
          [0-9]{2}/[0-9]{2}/[0-9]{4}$
          이 기능은 BRE를 사용하는 일부 프로그램에서 후방 참조라 불리고, 다음과 같이 동작한다. replacement에 \n 문자열이 포함되어 있으면 그 문자열은 앞선 정규 표현식에 해당하는 서브 표현식을 가리킨다. n은 1부터 9 사이의 숫자다. 서브 표현식을 만들려면 단순히 다음과 같이 괄호로 둘러싸면 된다.
          ([0-9]{2})/([0-9]{2})/([0-9]{4})$
          이제 세 개의 서브 표현식이 생겼다. 첫째는 월(month)을 포함하고, 둘째는 해당 월의 일자, 마지막 셋째는 연도를 포함한다. 이제 다음처럼 replacement를 만들 수 있다.
          \3-\1-\2 년, 대시, 월, 대시, 일 순서다.
          sed는 기본 정규식만 허용하므로, 정규 표현식 문자들이 메타 문자가 아닌 상수 문자로 처리된다. 따라서 백슬래시의 사용이 필요하다.

          sed는 유능한 프로그램이고, 긴 스크립트보다 한 줄짜리 간단한 작업을 위해 주로 사용된다. 많은 사람들은 awk와 perl을 사용한다.




  aspell: 대화식 맞춤법 검사기
          aspell 프로그램은 맞춤법 검사가 필요한 다른 프로그램에서 주로 사용된다. 또한 커맨드라인에서 단독 툴로서 효과적으로 사용될 수 있다. HTML 문서, C/C++ 프로그램, 이메일 메시지와 그 외 특수한 텍스트 등 다양한 종류의 텍스트 파일들을 지능적으로 검사하는 능력을 가지고 있다.

          aspell check -l en_US textfile

          aspell -H check textfile은 HTML의 마크업이 아닌 부분만 검사하게 된다. 태그의 내용은 무시되고 철자 검사만 한다.

          변경을 하게 되면 기존 파일에 변경이 되고, 백업 파일은 .bak 형태로 생긴다.

4. 텍스트의 응용
  -문서
    많은 사람들이 일반 텍스트 형식을 사용하여 문서를 작성한다. 하지만 텍스트 형식으로 큰 문서를 작성하는 것도 가능하다. 텍스트 형식으로 문서를 작성한 뒤, 최종 문서의 포맷을 기술하기 위해 마크업 언어(markup languages)를 사용한다. 유닉스 기반 텍스트 처리 시스템은 기술학 저자들에게 필요한 고급 조판 레이아웃을 지원하는 첫 번째 시스템들 중 하나다.

  -웹 페이지
    웹 페이지는 문서의 시각적 형식을 기술하기 위한 마크업 언어로 HTML 또는 XML을 사용하는 텍스트 문서다.

  -이메일
    이메일은 본질적으로 텍스트 기반 매체다. 첨부파일조차도 텍스트 표현 방식으로 전환된다.
    메시지의 출발지와 그 수신 경로를 나타내는 헤더(header)로 시작하여 내용물인 본문(body)를 보게 된다.

  -프린터 출력
    유닉스형 시스템에서 프린터 출력은 일반 텍스트로 보내지거나, 만약 그래픽을 포함하면 포스트스크립트(PostScript)로 변환된다.

  -프로그램 소스 코드
    커맨드라인 프로그램의 대다수는 유닉스형 시스템에서 쉽게 발견된다. 텍스트 처리가 중요한 이유는 소프트웨어 개발자의 모든 소프트웨어를 텍스트로 시작하기 때문이다. 소스 코드는 프로그래머가 실제로 작성한 프로그램의 부분으로 언제나 텍스트 형태다.

* MS-DOS 텍스트 vs. 유닉스 텍스트
cat으로 비출력 문자를 보기 원하는 이유 중 하나는 숨겨진 캐리지 리턴(carriage return)을 찾기 위해서다. 유닉스는 라인피드(linefeed) 문자(ASCII 10)로 행을 끝낸다. 반면 MS-DOS 계열은 각 행을 마치기 위해 캐리지 리턴(ASCII 13)과 라인피드 문자열을 사용한다.
도스에서 유닉스 포맷으로 파일을 변환하기 위한 여러 방법들이 있다. 하지만 dos2unix 절차는 매우 간단하다. 캐리지 리턴만을 제거하면 되기 때문에!


**
split(파일을 분리)
csplit(파일을 문맥 기반으로 분리)
sdiff(파일 차이점을 나란히 결합)
